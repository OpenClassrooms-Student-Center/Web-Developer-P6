var t={10:t=>{const i="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,s=new Set,e=(t,i)=>{const s=`LRU_CACHE_OPTION_${t}`;l(s)&&o(s,`${t} option`,`options.${i}`,d)},h=(t,i)=>{const s=`LRU_CACHE_METHOD_${t}`;if(l(s)){const{prototype:e}=d,{get:h}=Object.getOwnPropertyDescriptor(e,t);o(s,`${t} method`,`cache.${i}()`,h)}},l=t=>!(process.noDeprecation||s.has(t)),o=(t,i,e,h)=>{s.add(t),process.emitWarning(`The ${i} is deprecated. Please use ${e} instead.`,"DeprecationWarning",t,h)},n=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),a=t=>n(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?r:null:null;class r extends Array{constructor(t){super(t),this.fill(0)}}class p{constructor(t){const i=a(t);this.heap=new i(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class d{constructor(t={}){const{max:i,ttl:s,ttlResolution:h=1,ttlAutopurge:l,updateAgeOnGet:o,allowStale:r,dispose:c,disposeAfter:f,noDisposeOnSet:u,noUpdateTTL:z,maxSize:v,sizeCalculation:y}=t,{length:g,maxAge:m,stale:S}=t instanceof d?{}:t;if(!n(i))throw new TypeError("max option must be an integer");const L=a(i);if(!L)throw new Error("invalid max value: "+i);if(this.max=i,this.maxSize=v||0,this.sizeCalculation=y||g,this.sizeCalculation){if(!this.maxSize)throw new TypeError("cannot set sizeCalculation without setting maxSize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculating set to non-function")}if(this.keyMap=new Map,this.keyList=new Array(i).fill(null),this.valList=new Array(i).fill(null),this.next=new L(i),this.prev=new L(i),this.head=0,this.tail=0,this.free=new p(i),this.initialFill=1,this.size=0,"function"==typeof c&&(this.dispose=c),"function"==typeof f?(this.disposeAfter=f,this.disposed=[]):(this.disposeAfter=null,this.disposed=null),this.noDisposeOnSet=!!u,this.noUpdateTTL=!!z,this.maxSize){if(!n(this.maxSize))throw new TypeError("maxSize must be a positive integer if specified");this.initializeSizeTracking()}if(this.allowStale=!!r||!!S,this.updateAgeOnGet=!!o,this.ttlResolution=n(h)||0===h?h:1,this.ttlAutopurge=!!l,this.ttl=s||m||0,this.ttl){if(!n(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.initializeTTLTracking()}S&&e("stale","allowStale"),m&&e("maxAge","ttl"),g&&e("length","sizeCalculation")}initializeTTLTracking(){this.ttls=new r(this.max),this.starts=new r(this.max),this.setItemTTL=(t,s)=>{if(this.starts[t]=0!==s?i.now():0,this.ttls[t]=s,0!==s&&this.ttlAutopurge){const i=setTimeout((()=>{this.isStale(t)&&this.delete(this.keyList[t])}),s+1);i.unref&&i.unref()}},this.updateItemAge=t=>{this.starts[t]=0!==this.ttls[t]?i.now():0};let t=0;const s=()=>{const s=i.now();if(this.ttlResolution>0){t=s;const i=setTimeout((()=>t=0),this.ttlResolution);i.unref&&i.unref()}return s};this.isStale=i=>0!==this.ttls[i]&&0!==this.starts[i]&&(t||s())-this.starts[i]>this.ttls[i]}updateItemAge(t){}setItemTTL(t,i){}isStale(t){return!1}initializeSizeTracking(){this.calculatedSize=0,this.sizes=new r(this.max),this.removeItemSize=t=>this.calculatedSize-=this.sizes[t],this.addItemSize=(t,i,s,e,h)=>{const l=e||(h?h(i,s):0);this.sizes[t]=n(l)?l:0;const o=this.maxSize-this.sizes[t];for(;this.calculatedSize>o;)this.evict();this.calculatedSize+=this.sizes[t]},this.delete=t=>{if(0!==this.size){const i=this.keyMap.get(t);void 0!==i&&(this.calculatedSize-=this.sizes[i])}return d.prototype.delete.call(this,t)}}removeItemSize(t){}addItemSize(t,i,s,e,h){}*indexes(){if(this.size)for(let t=this.tail;this.isStale(t)||(yield t),t!==this.head;t=this.prev[t]);}*rindexes(){if(this.size)for(let t=this.head;this.isStale(t)||(yield t),t!==this.tail;t=this.next[t]);}*entries(){for(const t of this.indexes())yield[this.keyList[t],this.valList[t]]}*keys(){for(const t of this.indexes())yield this.keyList[t]}*values(){for(const t of this.indexes())yield this.valList[t]}[Symbol.iterator](){return this.entries()}find(t,i={}){for(const s of this.indexes())if(t(this.valList[s],this.keyList[s],this))return this.get(this.keyList[s],i)}forEach(t,i=this){for(const s of this.indexes())t.call(i,this.valList[s],this.keyList[s],this)}rforEach(t,i=this){for(const s of this.rindexes())t.call(i,this.valList[s],this.keyList[s],this)}get prune(){return h("prune","purgeStale"),this.purgeStale}purgeStale(){let t=!1;if(this.size)for(let i=this.head;;i=this.next[i]){const s=i===this.tail;if(this.isStale(i)&&(this.delete(this.keyList[i]),t=!0),s)break}return t}dump(){const t=[];for(const i of this.indexes()){const s=this.keyList[i],e={value:this.valList[i]};this.ttls&&(e.ttl=this.ttls[i]),this.sizes&&(e.size=this.sizes[i]),t.unshift([s,e])}return t}load(t){this.clear();for(const[i,s]of t)this.set(i,s.value,s)}dispose(t,i,s){}set(t,i,{ttl:s=this.ttl,noDisposeOnSet:e=this.noDisposeOnSet,size:h=0,sizeCalculation:l=this.sizeCalculation,noUpdateTTL:o=this.noUpdateTTL}={}){let n=0===this.size?void 0:this.keyMap.get(t);if(void 0===n)n=this.newIndex(),this.keyList[n]=t,this.valList[n]=i,this.keyMap.set(t,n),this.next[this.tail]=n,this.prev[n]=this.tail,this.tail=n,this.size++,this.addItemSize(n,i,t,h,l),o=!1;else{const s=this.valList[n];i!==s&&(e||(this.dispose(s,t,"set"),this.disposeAfter&&this.disposed.push([s,t,"set"])),this.removeItemSize(n),this.valList[n]=i,this.addItemSize(n,i,t,h,l)),this.moveToTail(n)}if(0===s||0!==this.ttl||this.ttls||this.initializeTTLTracking(),o||this.setItemTTL(n,s),this.disposeAfter)for(;this.disposed.length;)this.disposeAfter(...this.disposed.shift());return this}newIndex(){return 0===this.size?this.tail:this.size===this.max?this.evict():0!==this.free.length?this.free.pop():this.initialFill++}pop(){if(this.size){const t=this.valList[this.head];return this.evict(),t}}evict(){const t=this.head,i=this.keyList[t],s=this.valList[t];return this.dispose(s,i,"evict"),this.disposeAfter&&this.disposed.push([s,i,"evict"]),this.removeItemSize(t),this.head=this.next[t],this.keyMap.delete(i),this.size--,t}has(t){return this.keyMap.has(t)&&!this.isStale(this.keyMap.get(t))}peek(t,{allowStale:i=this.allowStale}={}){const s=this.keyMap.get(t);if(void 0!==s&&(i||!this.isStale(s)))return this.valList[s]}get(t,{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet}={}){const e=this.keyMap.get(t);if(void 0!==e){if(this.isStale(e)){const s=i?this.valList[e]:void 0;return this.delete(t),s}return this.moveToTail(e),s&&this.updateItemAge(e),this.valList[e]}}connect(t,i){this.prev[i]=t,this.next[t]=i}moveToTail(t){t!==this.tail&&(t===this.head?this.head=this.next[t]:this.connect(this.prev[t],this.next[t]),this.connect(this.tail,t),this.tail=t)}get del(){return h("del","delete"),this.delete}delete(t){let i=!1;if(0!==this.size){const s=this.keyMap.get(t);void 0!==s&&(i=!0,1===this.size?this.clear():(this.removeItemSize(s),this.dispose(this.valList[s],t,"delete"),this.disposeAfter&&this.disposed.push([this.valList[s],t,"delete"]),this.keyMap.delete(t),this.keyList[s]=null,this.valList[s]=null,s===this.tail?this.tail=this.prev[s]:s===this.head?this.head=this.next[s]:(this.next[this.prev[s]]=this.next[s],this.prev[this.next[s]]=this.prev[s]),this.size--,this.free.push(s)))}if(this.disposed)for(;this.disposed.length;)this.disposeAfter(...this.disposed.shift());return i}clear(){if(this.dispose!==d.prototype.dispose)for(const t of this.rindexes())this.dispose(this.valList[t],this.keyList[t],"delete");if(this.disposeAfter)for(const t of this.rindexes())this.disposed.push([this.valList[t],this.keyList[t],"delete"]);if(this.keyMap.clear(),this.valList.fill(null),this.keyList.fill(null),this.ttls&&(this.ttls.fill(0),this.starts.fill(0)),this.sizes&&this.sizes.fill(0),this.head=0,this.tail=0,this.initialFill=1,this.free.length=0,this.calculatedSize=0,this.size=0,this.disposed)for(;this.disposed.length;)this.disposeAfter(...this.disposed.shift())}get reset(){return h("reset","clear"),this.clear}get length(){return((t,i)=>{const s="LRU_CACHE_PROPERTY_length";if(l(s)){const{prototype:i}=d,{get:e}=Object.getOwnPropertyDescriptor(i,t);o(s,"length property","cache.size",e)}})("length"),this.size}}t.exports=d}},i={};!function s(e){var h=i[e];if(void 0!==h)return h.exports;var l=i[e]={exports:{}};return t[e](l,l.exports,s),l.exports}(10);